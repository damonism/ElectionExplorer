{
    "collab_server" : "",
    "contents" : "library(shiny)\nlibrary(leaflet)\nlibrary(htmltools)\nlibrary(sp)\nlibrary(rgdal)\n\n##\n## TODO:\n## - Slider to only show polling places of a certain size\n## - Fix up the UI.\n## - Pre-poll and super-booth toggle\n## - Collapse polling places at the same location together.\n## - Mark abolished polling places and gather their votes into the nearest remaining [hard!]\n\n\n# ##\n# ## Download the 2013 results by polling place\n# ##\n# \n# # 2013 First HoR First Preference by PP\n# hor_2013 <- read.csv2(\"http://results.aec.gov.au/17496/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-17496-NSW.csv\", header=TRUE, skip=1, sep=\",\")\n# hor_2013 <- rbind(hor_2013, read.csv2(\"http://results.aec.gov.au/17496/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-17496-VIC.csv\", header=TRUE, skip=1, sep=\",\"))\n# hor_2013 <- rbind(hor_2013, read.csv2(\"http://results.aec.gov.au/17496/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-17496-QLD.csv\", header=TRUE, skip=1, sep=\",\"))\n# hor_2013 <- rbind(hor_2013, read.csv2(\"http://results.aec.gov.au/17496/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-17496-WA.csv\", header=TRUE, skip=1, sep=\",\"))\n# hor_2013 <- rbind(hor_2013, read.csv2(\"http://results.aec.gov.au/17496/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-17496-SA.csv\", header=TRUE, skip=1, sep=\",\"))\n# hor_2013 <- rbind(hor_2013, read.csv2(\"http://results.aec.gov.au/17496/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-17496-TAS.csv\", header=TRUE, skip=1, sep=\",\"))\n# hor_2013 <- rbind(hor_2013, read.csv2(\"http://results.aec.gov.au/17496/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-17496-ACT.csv\", header=TRUE, skip=1, sep=\",\"))\n# hor_2013 <- rbind(hor_2013, read.csv2(\"http://results.aec.gov.au/17496/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-17496-NT.csv\", header=TRUE, skip=1, sep=\",\"))\n# hor_2013$Election <- \"2013\"\n# \n# # It's probably easier to use PartyAb than PartyNm, but put \"Informal\" in the otherwise\n# # black PartyAb for informal votes.\n# \n# hor_2013$PartyAb <- as.character(hor_2013$PartyAb)\n# hor_2013$PartyAb[hor_2013$PartyNm == \"Informal\"] <- \"Informal\"\n# hor_2013$PartyAb <- as.factor(hor_2013$PartyAb)\n# \n# library(reshape2)\n# result_by_pp_2013 <- dcast(hor_2013, StateAb + DivisionNm + PollingPlace + PollingPlaceID ~ PartyAb, sum, value.var = \"OrdinaryVotes\")\n# result_by_pp_2013$TotalVotes <- rowSums(result_by_pp_2013[,!colnames(result_by_pp_2013) %in% c(\"StateAb\", \"DivisionNm\", \"PollingPlace\", \"PollingPlaceID\")])\n# \n# # Toby's fixed 2016 boundaries\n# boundaries_new_2016 <- readOGR(\"2016 Commonwealth Boundaries/Fixed\", \"COM_ELB_20160509\")\n# \n# # Reduce the complexity of the district boundary map (default is 46mb)\n# library(rgeos)\n# boundaries_big_2016 <- boundaries_new_2016\n# tmp_data <- data.frame(boundaries_big_2016)\n# tmp_shape <- gSimplify(boundaries_big_2016, tol = .01, topologyPreserve = TRUE)\n# boundaries_new_2016 <- SpatialPolygonsDataFrame(tmp_shape, tmp_data)\n# rm(tmp_shape)\n# rm(tmp_data)\n# \n# # The variable names are different in the redistribution maps, so we need to rename them\n# names(boundaries_new_2016)[names(boundaries_new_2016) == \"Elect_div\"] <- \"ELECT_DIV\"\n# names(boundaries_new_2016)[names(boundaries_new_2016) == \"Actual\"] <- \"ACTUAL\"\n# names(boundaries_new_2016)[names(boundaries_new_2016) == \"Numccds\"] <- \"NUMCCDS\"\n# names(boundaries_new_2016)[names(boundaries_new_2016) == \"Area_SqKm\"] <- \"AREA_SQKM\"\n# names(boundaries_new_2016)[names(boundaries_new_2016) == \"Projected\"] <- \"PROJECTED\"\n# names(boundaries_new_2016)[names(boundaries_new_2016) == \"Sortname\"] <- \"SORTNAME\"\n# names(boundaries_new_2016)[names(boundaries_new_2016) == \"Total_Popu\"] <- \"POPULATION\"\n# \n# # Some of the division names are not capitalised properly, and this messes up the merge with the notional status\n# levels(boundaries_new_2016$ELECT_DIV) <- gsub(\"Mcpherson\", \"McPherson\", levels(boundaries_new_2016$ELECT_DIV))\n# levels(boundaries_new_2016$ELECT_DIV) <- gsub(\"Mcmillan\", \"McMillan\", levels(boundaries_new_2016$ELECT_DIV))\n# \n# # Add the notional status\n# notional_status <- read.csv(\"Notional.csv\")\n# boundaries_new_2016 <- merge(boundaries_new_2016, notional_status)\n# \n# # Okay, worked out what I did wrong last time is I need to make two sets of polygons, one for ALP and one for Coalition\n# \n# boundaries_2016_coalition <- boundaries_new_2016[boundaries_new_2016$Notional == \"Coalition\",]\n# boundaries_2016_alp <- boundaries_new_2016[boundaries_new_2016$Notional == \"ALP\",]\n# boundaries_2016_nonclassic <- boundaries_new_2016[boundaries_new_2016$Notional == \"Non-Classic\",]\n# \n# # Invert the ALP margins (turn them into minus margins)\n# boundaries_new_2016$RelMargin <- boundaries_new_2016$Margin\n# boundaries_new_2016$RelMargin[boundaries_new_2016$Notional == \"ALP\"] <- 0 - boundaries_new_2016$Margin[boundaries_new_2016$Notional == \"ALP\"]\n# \n# ##\n# ## Polling places\n# ##\n# \n# pp_geo <- read.csv(\"http://results.aec.gov.au/17496/Website/Downloads/GeneralPollingPlacesDownload-17496.csv\", header = TRUE, skip = 1)\n# tcp_by_pp <- read.csv(\"http://results.aec.gov.au/17496/Website/Downloads/HouseTcpByCandidateByPollingPlaceDownload-17496.csv\", header = TRUE, skip = 1)\n# \n# library(reshape2)\n# tcp_party_pp <- dcast(tcp_by_pp, PollingPlaceID + PollingPlace ~ PartyAb, value.var = \"OrdinaryVotes\")\n# tcp_party_pp$COA <- rowSums(cbind(tcp_party_pp$LP, tcp_party_pp$CLP, tcp_party_pp$LNP, tcp_party_pp$NP), na.rm = TRUE)\n# tcp_party_pp$TotalVotes <- tcp_party_pp$ALP + tcp_party_pp$COA\n# tcp_party_pp$PercentALP <- tcp_party_pp$ALP / tcp_party_pp$TotalVotes\n# tcp_party_pp$PercentCOA <- tcp_party_pp$COA / tcp_party_pp$TotalVotes\n# \n# # Because we're going to merge this with the full polling place results by party, we need to identify these as TPP results by party\n# names(tcp_party_pp) <- gsub(\"^\", \"tpp\", names(tcp_party_pp))\n# names(tcp_party_pp)[1] <- \"PollingPlaceID\"\n# \n# # Merge TPP and Geocodes\n# tcp_party_pp <- merge(tcp_party_pp, pp_geo, by = \"PollingPlaceID\", all.x = TRUE)\n# \n# # Merge this with the results\n# tcp_party_pp <- merge(tcp_party_pp, result_by_pp_2013, by = \"PollingPlaceID\", all.x = TRUE)\n# \n# # We don't want polling places with no geocodes\n# tcp_party_pp <- tcp_party_pp[!is.na(tcp_party_pp$Longitude),]\n# \n# # Some polling places have a dodgy geocode\n# tcp_party_pp <- tcp_party_pp[tcp_party_pp$Longitude > 0,]\n# # Dandenong West is on Christmas Island, for some reason\n# tcp_party_pp <- tcp_party_pp[tcp_party_pp$PollingPlaceID != 3965,]\n# \n# # And the mapping is easier if we delete the Norfolk Island polling places (sorry Norfolk Island)\n# tcp_party_pp <- tcp_party_pp[tcp_party_pp$PremisesPostCode != 7140,]\n# # And Lord Howe Island\n# tcp_party_pp <- tcp_party_pp[tcp_party_pp$PremisesPostCode != 2898,]\n# # Home Island\n# tcp_party_pp <- tcp_party_pp[tcp_party_pp$PremisesPostCode != 6799,]\n# # Christmas Island\n# tcp_party_pp <- tcp_party_pp[tcp_party_pp$PremisesPostCode != 6798,]\n# \n# # Also get rid of the polling places which don't have any votes\n# tcp_party_pp <- tcp_party_pp[tcp_party_pp$TotalVotes > 0,]\n# \n# # Tell R what the Latitudes and Longitudes are\n# coordinates(tcp_party_pp) <- c(\"Longitude\", \"Latitude\")\n# proj4string(tcp_party_pp) <- proj4string(boundaries_new_2016)\n# \n# tcp_party_pp <- tcp_party_pp[!is.na(tcp_party_pp$PollingPlaceID),]\n# \n# # Percantage results for ALP, Coalition, Greens\n# tcp_party_pp$PercentALP <- tcp_party_pp$ALP / tcp_party_pp$TotalVotes * 100\n# tcp_party_pp$PercentCOA <- (tcp_party_pp$LP + tcp_party_pp$NP + tcp_party_pp$CLP + tcp_party_pp$LNP) / tcp_party_pp$TotalVotes * 100\n# tcp_party_pp$PercentGRN <- tcp_party_pp$GRN / tcp_party_pp$TotalVotes * 100\n# \n# # Break down polling places into TPP groups\n# tcp_pp_alp <- tcp_party_pp[!is.na(tcp_party_pp$tppPercentALP),]\n# tcp_pp_alp <- tcp_pp_alp[tcp_pp_alp$tppPercentALP >= 0.5,]\n# \n# # Determine relative margin (ALP with negative margins)\n# tcp_party_pp$tppRelative <- tcp_party_pp$tppPercentCOA - 0.5\n# \n# tcp_pp_coa <- tcp_party_pp[!is.na(tcp_party_pp$tppPercentCOA),]\n# tcp_pp_coa <- tcp_pp_coa[tcp_pp_coa$tppPercentCOA >= 0.5,]\n\n\nui <- fluidPage(\n  titlePanel(\"2013 Election Results Explorer\"),\n  tags$style(type = \"text/css\", \"#map {height: calc(100vh - 80px) !important;}\"),\n  leafletOutput(\"map\"),\n  \n  absolutePanel(\n    top = 70, right = 20, width = 300,\n    draggable = TRUE,\n    style = \"opacity: 0.92\",\n    radioButtons(\"polling_place_markers\", \"Polling Place Markers\",\n                 choices = list(\"Two Party Preferred\" = \"tpp\",\n                                \"Coalition Primary\" = \"coa\",\n                                \"ALP Primary\" = \"alp\",\n                                \"Greens Primary\" = \"grn\"),\n                 selected = \"tpp\"),\n    # checkboxGroupInput(\"boundaries\", \"Boundaries\",\n    #                    choices = list(\"2016 Notional Margin\" = \"margin\",\n    #                                   \"2016 Boundary\" = \"outline\"),\n    #                    selected = \"margin\"),\n    checkboxInput(\"no_ppvc\", \"Exclude pre-polls\"),\n    selectInput(\"division\", \"Zoom to Division\", c(\"Select a division\" = \"\", levels(boundaries_new_2016$ELECT_DIV)))\n  )\n)\n\nserver <- function(input, output) {\n  output$map <- renderLeaflet({\n    leaflet(boundaries_new_2016) %>% \n      addTiles() %>% \n     addProviderTiles(\"CartoDB.Positron\") %>%\n      fitBounds(~min(tcp_party_pp$Longitude), \n                ~min(tcp_party_pp$Latitude), \n                ~max(tcp_party_pp$Longitude), \n                ~max(tcp_party_pp$Latitude))\n\n  })\n  \n  \n  ##\n  ## Draw the boundaries as filled polygons shaded by margin\n  ##\n  \n  observe({\n    \n    content_alp <- paste(\n      \"<b>\", htmlEscape(boundaries_2016_alp$ELECT_DIV), \"</b><br />\",\n      \"Notional Party:\", htmlEscape(boundaries_2016_alp$Notional), \"<br />\",\n      \"Notional Margin:\", htmlEscape(round(boundaries_2016_alp$Margin, digits = 1)), \"<br />\",\n      \"Held By:\", htmlEscape(boundaries_2016_alp$HeldBy), \"<br />\"\n    )\n    \n    content_coalition <- paste(\n      \"<b>\", boundaries_2016_coalition$ELECT_DIV, \"</b><br />\",\n      \"Notional Party:\", boundaries_2016_coalition$Notional, \"<br />\",\n      \"Notional Margin:\", round(boundaries_2016_coalition$Margin, digits = 1), \"<br />\",\n      \"Held By:\", boundaries_2016_coalition$HeldBy, \"<br />\"\n    )\n    \n    content_nonclassic <- paste(\n      \"<b>\", boundaries_2016_nonclassic$ELECT_DIV, \"</b><br />\",\n      \"Notional Party:\", boundaries_2016_nonclassic$Notional, \"<br />\",\n      \"Notional Margin:\", round(boundaries_2016_nonclassic$Margin, digits = 1), \"<br />\",\n      \"Held By:\", boundaries_2016_nonclassic$HeldBy, \"<br />\"\n    )\n    \n    \n    pal_coalition <- colorNumeric(\n      palette = \"Blues\", \n      domain = boundaries_new_2016$Margin\n    )\n    \n    pal_alp <- colorNumeric(\n      palette = \"Reds\", \n      domain = boundaries_new_2016$Margin\n    )\n    \n    pal_nonclassic <- colorNumeric(\n      palette = \"Greens\",\n      domain = boundaries_new_2016$Margin\n    )  \n    \n    leafletProxy(\"map\", data = boundaries_2016_alp) %>% \n      addPolygons(color = ~pal_alp(boundaries_2016_alp$Margin), popup = content_alp, \n                  stroke = TRUE, weight = 1, fillOpacity = 0.5, group = \"Notional Margin\")\n    leafletProxy(\"map\", data = boundaries_2016_coalition) %>% \n      addPolygons(color = ~pal_coalition(boundaries_2016_coalition$Margin), popup = content_coalition, \n                  stroke = TRUE, weight = 1, fillOpacity = 0.5, group = \"Notional Margin\")\n    leafletProxy(\"map\", data = boundaries_2016_nonclassic) %>% \n      addPolygons(color = ~pal_nonclassic(boundaries_2016_nonclassic$Margin), popup = content_nonclassic, \n                  stroke = TRUE, weight = 1, fillOpacity = 0.5, group = \"Notional Margin\")\n    leafletProxy(\"map\", data = boundaries_new_2016) %>% \n      addPolylines(weight = 1, stroke = TRUE, opacity = 1, color = \"Black\", group = \"2016 Boundary\")\n\n    # For some reason this is *really* slow, at least on my computer.     \n    if(\"margin\" %in% input$boundaries){\n      leafletProxy(\"map\") %>% showGroup(\"Notional Margin\")\n    } else {\n      leafletProxy(\"map\") %>% hideGroup(\"Notional Margin\")\n    }\n    \n    if(\"outline\" %in% input$boundaries){\n      leafletProxy(\"map\") %>% showGroup(\"2016 Boundary\")\n    } else {\n      leafletProxy(\"map\") %>% hideGroup(\"2016 Boundary\")\n    }\n    \n    leafletProxy(\"map\") %>% addLayersControl(\n      position = \"bottomright\",\n      options = layersControlOptions(collapsed = FALSE),\n      overlayGroups = c(\"Notional Margin\", \"2016 Boundary\")\n    )\n    \n    \n  })\n  \n  ##\n  ## Draw the two-party preferred polling place markers\n  ##\n  \n  # observe({\n  #   \n  #   pal_pp_alp <- colorNumeric(\n  #     palette = \"Reds\",\n  #     domain = tcp_pp_alp$tppPercentALP\n  #   )\n  #   \n  #   pal_pp_coa <- colorNumeric(\n  #     palette = \"Blues\",\n  #     domain = tcp_pp_coa$tppPercentCOA\n  #   )\n  #   \n  #   pal_grn_percent <- colorNumeric(\n  #     palette = \"Greens\",\n  #     domain = tcp_party_pp$PercentGRN\n  #   )\n  #   \n  #   pal_alp_percent <- colorNumeric(\n  #     palette = \"Reds\",\n  #     domain = tcp_party_pp$PercentALP\n  #   )\n  #   \n  #   pal_coa_percent <- colorNumeric(\n  #     palette = \"Blues\",\n  #     domain = tcp_party_pp$PercentCOA\n  #   )\n  #   \n  #   content_tcp_alp <- paste(\n  #     \"<b>\", tcp_pp_alp$PollingPlace, \" (\", tcp_pp_alp$PremisesSuburb, \", \", tcp_pp_alp$PremisesStateAb, \")</b><br />\",\n  #     \"Division of \", tcp_pp_alp$DivisionNm.x, \"<br>\",\n  #     \"ALP primary vote: \", tcp_pp_alp$ALP, \" (\", round(tcp_pp_alp$PercentALP, digits = 1), \"%)<br />\",\n  #     \"ALP Two Party Preferred: \", round(tcp_pp_alp$tppPercentALP * 100, digits = 1), \"%<br />\",\n  #     \"Coalition primary vote: \", tcp_pp_alp$COA, \" (\", round(tcp_pp_alp$PercentCOA, digits = 1), \"%)<br />\",\n  #     \"Coalition Two Party Preferred: \", round(tcp_pp_alp$tppPercentCOA * 100, digits = 1), \"%<br />\",\n  #     \"Greens primary vote: \", tcp_pp_alp$GRN, \" (\", round(tcp_pp_alp$PercentGRN, digits = 1), \"%)<br />\",\n  #     \"Total votes: \", tcp_pp_alp$TotalVotes, \"<br />\",\n  #     sep = \"\"\n  #   )\n  #   \n  #   content_tcp_coa <- paste(\n  #     \"<b>\", tcp_pp_coa$PollingPlace, \" (\", tcp_pp_coa$PremisesSuburb, \", \", tcp_pp_coa$PremisesStateAb, \")</b><br />\",\n  #     \"Division of \", tcp_pp_coa$DivisionNm.x, \"<br>\",\n  #     \"ALP primary vote: \", tcp_pp_coa$ALP, \" (\", round(tcp_pp_coa$PercentALP, digits = 1), \"%)<br />\",\n  #     \"ALP Two Party Preferred: \", round(tcp_pp_coa$tppPercentALP * 100, digits = 1), \"%<br />\",\n  #     \"Coalition primary vote: \", tcp_pp_coa$COA, \" (\", round(tcp_pp_coa$PercentCOA, digits = 1), \"%)<br />\",\n  #     \"Coalition Two Party Preferred: \", round(tcp_pp_coa$tppPercentCOA * 100, digits = 1), \"%<br />\",\n  #     \"Greens primary vote: \", tcp_pp_coa$GRN, \" (\", round(tcp_pp_coa$PercentGRN, digits = 1), \"%)<br />\",\n  #     \"Total votes: \", tcp_pp_coa$TotalVotes, \"<br />\",\n  #     sep = \"\"\n  #   )\n  #   \n  #   # Content bubble for COA/ALP/GRN polling places\n  #   content_pp <- paste(\n  #     \"<b>\", htmlEscape(tcp_party_pp$PollingPlace), \n  #     \" (\", htmlEscape(tcp_party_pp$PremisesSuburb), \", \", htmlEscape(tcp_party_pp$PremisesStateAb), \")</b><br />\",\n  #     \"Division of \", tcp_party_pp$DivisionNm.x, \"<br>\",\n  #     \"ALP primary vote: \", tcp_party_pp$ALP, \" (\", round(tcp_party_pp$PercentALP, digits = 1), \"%)<br />\",\n  #     \"ALP Two Party Preferred: \", round(tcp_party_pp$tppPercentALP * 100, digits = 1), \"%)<br />\",\n  #     \"Coalition primary vote: \", tcp_party_pp$COA, \" (\", round(tcp_party_pp$PercentCOA, digits = 1), \"%)<br />\",\n  #     \"Coalition Two Party Preferred: \", round(tcp_party_pp$tppPercentCOA * 100, digits = 1), \"%)<br />\",\n  #     \"Greens primary vote: \", tcp_party_pp$GRN, \" (\", round(tcp_party_pp$PercentGRN, digits = 1), \"%)<br />\",\n  #     \"Total votes: \", tcp_party_pp$TotalVotes, \"<br />\",\n  #     sep = \"\"\n  #   )\n  #   \n  #   #\n  #   # Select which layer to show\n  #   #\n  #   \n  #   # Show the Two Party Preferred\n  #   if(input$polling_place_markers == \"tpp\"){\n  #     leafletProxy(\"map\") %>% clearMarkers()\n  #     leafletProxy(\"map\", data = tcp_pp_alp ) %>% \n  #       addCircleMarkers(popup = content_tcp_alp, color = ~pal_pp_alp(tcp_pp_alp$tppPercentALP), stroke = FALSE, \n  #                        radius = 3, fillOpacity = 0.8, group = \"Two Party Preferred\")\n  #     \n  #     leafletProxy(\"map\", data = tcp_pp_coa ) %>% \n  #       addCircleMarkers(popup = content_tcp_coa, color = ~pal_pp_coa(tcp_pp_coa$tppPercentCOA), stroke = FALSE, \n  #                        radius = 3, fillOpacity = 0.8, group = \"Two Party Preferred\")\n  #     \n  #     #            leafletProxy(\"map\") %>% showGroup(\"Two Party Preferred\") %>% \n  #     #        hideGroup(\"Coalition Primary\") %>% hideGroup(\"ALP Primary\") %>% hideGroup(\"Greens Primary\")\n  #     \n  #   }\n  #   \n  #   # Show the Coalition\n  #   if(input$polling_place_markers == \"coa\"){\n  #     leafletProxy(\"map\") %>% clearMarkers()\n  #     \n  #     leafletProxy(\"map\", data = tcp_party_pp ) %>% \n  #       addCircleMarkers(popup = content_pp, color = ~pal_coa_percent(tcp_party_pp$PercentCOA), stroke = FALSE, \n  #                        radius = 3, fillOpacity = 0.8, group = \"Coalition Primary\")\n  #     \n  #     \n  #     #      leafletProxy(\"map\") %>% showGroup(\"Coalition Primary\") %>% \n  #     #        hideGroup(\"Two Party Preferred\") %>% hideGroup(\"ALP Primary\") %>% hideGroup(\"Greens Primary\")\n  #   }\n  #   \n  #   # Show the ALP\n  #   if(input$polling_place_markers == \"alp\"){\n  #     \n  #     leafletProxy(\"map\") %>% clearMarkers()\n  #     leafletProxy(\"map\", data = tcp_party_pp ) %>% \n  #       addCircleMarkers(popup = content_pp, color = ~pal_alp_percent(tcp_party_pp$PercentALP), stroke = FALSE, \n  #                        radius = 3, fillOpacity = 0.8, group = \"ALP Primary\")\n  #     #      leafletProxy(\"map\") %>% showGroup(\"ALP Primary\") %>% \n  #     #        hideGroup(\"Two Party Preferred\") %>% hideGroup(\"Coalition Primary\") %>% hideGroup(\"Greens Primary\")\n  #   }\n  #   \n  #   # Show the Greens\n  #   if(input$polling_place_markers == \"grn\"){\n  #     \n  #     leafletProxy(\"map\") %>% clearMarkers()\n  #     leafletProxy(\"map\", data = tcp_party_pp ) %>% \n  #       addCircleMarkers(popup = content_pp, color = ~pal_grn_percent(tcp_party_pp$PercentGRN), stroke = FALSE, \n  #                        radius = 3, fillOpacity = 0.8, group = \"Greens Primary\")\n  #     \n  #     # leafletProxy(\"map\") %>% \n  #     #   addLegend(position = \"bottomleft\")\n  #     \n  #     #      leafletProxy(\"map\") %>% showGroup(\"Greens Primary\") %>% \n  #     #        hideGroup(\"Two Party Preferred\") %>% hideGroup(\"ALP Primary\") %>% hideGroup(\"Coalition Primary\")\n  #   }\n  #})\n  \n  #\n  # Zoom to a particular division\n  #\n  observe({\n    if(input$division != \"\"){\n      div_shape <- bbox(boundaries_new_2016[boundaries_new_2016$ELECT_DIV == input$division,])\n      leafletProxy(\"map\") %>% \n        fitBounds(div_shape[1], div_shape[2], div_shape[3], div_shape[4])\n    }\n  })\n  \n  observe({\n    filter_pps <- reactive({\n      if(input$no_ppvc) {\n        tcp_party_pp[!grepl(\"PPVC|Divisional Office (PREPOLL)\", tcp_party_pp$PollingPlaceNm),]\n      } else {\n        tcp_party_pp\n      }\n    })\n\n    data_pp <- filter_pps()\n\n    pp_value <- reactive({\n      if(input$polling_place_markers == \"tpp\") {\n        return(data_pp$tppRelative)\n      }\n      if(input$polling_place_markers == \"coa\") {\n        return(data_pp$PercentCOA)\n      }\n      if(input$polling_place_markers == \"alp\") {\n        return(data_pp$PercentALP)\n      }\n      if(input$polling_place_markers == \"grn\") {\n        return(data_pp$PercentGRN)\n      }\n      \n    })\n    \n    colour_pp <- reactive({\n      if(input$polling_place_markers == \"tpp\") {\n        colour_pp_colours = c(\"Red\", \"White\", \"Blue\")\n      }\n      if(input$polling_place_markers == \"coa\") {\n        colour_pp_colours = \"Blues\"\n      }\n      if(input$polling_place_markers == \"alp\") {\n        colour_pp_colours = \"Reds\"\n      }\n      if(input$polling_place_markers == \"grn\") {\n        colour_pp_colours = \"Greens\"\n      }\n      return(colour_pp_colours)\n    })\n    \n    pal <- colorNumeric(\n      palette = colour_pp(),\n      domain = pp_value()\n    )\n    \n    content_pp <- paste(\n      \"<b>\", htmlEscape(data_pp$PollingPlace),\n      \" (\", htmlEscape(data_pp$PremisesSuburb), \", \", htmlEscape(data_pp$PremisesStateAb), \")</b><br />\",\n      \"Division of \", data_pp$DivisionNm.x, \"<br>\",\n      \"ALP primary vote: \", data_pp$ALP, \" (\", round(data_pp$PercentALP, digits = 1), \"%)<br />\",\n      \"ALP Two Party Preferred: \", round(data_pp$tppPercentALP * 100, digits = 1), \"%)<br />\",\n      \"Coalition primary vote: \", data_pp$COA, \" (\", round(data_pp$PercentCOA, digits = 1), \"%)<br />\",\n      \"Coalition Two Party Preferred: \", round(data_pp$tppPercentCOA * 100, digits = 1), \"%)<br />\",\n      \"Greens primary vote: \", data_pp$GRN, \" (\", round(data_pp$PercentGRN, digits = 1), \"%)<br />\",\n      \"Total votes: \", data_pp$TotalVotes, \"<br />\",\n      sep = \"\"\n    )\n    \n    \n    #leafletProxy(\"map\") %>% clearMarkers()\n    leafletProxy(\"map\", data = data_pp) %>% \n      addCircleMarkers(popup = content_pp, color = ~pal(pp_value()), stroke = FALSE, \n                       radius = 3, fillOpacity = 0.8)\n    \n  })\n}\n\n\n\nshinyApp(ui, server)",
    "created" : 1463649348295.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3311927964",
    "id" : "C28E3047",
    "lastKnownWriteTime" : 1464261913,
    "last_content_update" : 1464261913549,
    "path" : "~/Documents/Dev/R/Electoral Map 2016/app.R",
    "project_path" : "app.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}