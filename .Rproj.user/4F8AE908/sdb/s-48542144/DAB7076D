{
    "collab_server" : "",
    "contents" : "library(sp)\nlibrary(rgdal)\n\n##\n## Download the 2013 results by polling place\n##\n\n# 2013 First HoR First Preference by PP\nhor_2013 <- read.csv2(\"http://results.aec.gov.au/17496/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-17496-NSW.csv\", header=TRUE, skip=1, sep=\",\")\nhor_2013 <- rbind(hor_2013, read.csv2(\"http://results.aec.gov.au/17496/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-17496-VIC.csv\", header=TRUE, skip=1, sep=\",\"))\nhor_2013 <- rbind(hor_2013, read.csv2(\"http://results.aec.gov.au/17496/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-17496-QLD.csv\", header=TRUE, skip=1, sep=\",\"))\nhor_2013 <- rbind(hor_2013, read.csv2(\"http://results.aec.gov.au/17496/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-17496-WA.csv\", header=TRUE, skip=1, sep=\",\"))\nhor_2013 <- rbind(hor_2013, read.csv2(\"http://results.aec.gov.au/17496/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-17496-SA.csv\", header=TRUE, skip=1, sep=\",\"))\nhor_2013 <- rbind(hor_2013, read.csv2(\"http://results.aec.gov.au/17496/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-17496-TAS.csv\", header=TRUE, skip=1, sep=\",\"))\nhor_2013 <- rbind(hor_2013, read.csv2(\"http://results.aec.gov.au/17496/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-17496-ACT.csv\", header=TRUE, skip=1, sep=\",\"))\nhor_2013 <- rbind(hor_2013, read.csv2(\"http://results.aec.gov.au/17496/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-17496-NT.csv\", header=TRUE, skip=1, sep=\",\"))\nhor_2013$Election <- \"2013\"\n\n# It's probably easier to use PartyAb than PartyNm, but put \"Informal\" in the otherwise\n# black PartyAb for informal votes.\n\nhor_2013$PartyAb <- as.character(hor_2013$PartyAb)\nhor_2013$PartyAb[hor_2013$PartyNm == \"Informal\"] <- \"Informal\"\nhor_2013$PartyAb <- as.factor(hor_2013$PartyAb)\n\nlibrary(reshape2)\nresult_by_pp_2013 <- dcast(hor_2013, StateAb + DivisionNm + PollingPlace + PollingPlaceID ~ PartyAb, sum, value.var = \"OrdinaryVotes\") \nresult_by_pp_2013$TotalVotes <- rowSums(result_by_pp_2013[,!colnames(result_by_pp_2013) %in% c(\"StateAb\", \"DivisionNm\", \"PollingPlace\", \"PollingPlaceID\")])\n\n# Don't need any of this any more because I have the fixed 2016 map from Toby\n#\n# boundaries_aust_2013 <- readOGR(\"//home4/mullerd$/My Documents/Data/2013 Commonwealth Boundaries\", \"COM20111216_ELB_region\")\n# boundaries_nsw_2016 <- readOGR(\"//home4/mullerd$/My Documents/Data/2016 Commonwealth Boundaries\", \"NSW_Electoral_Boundaries_25-02-2016\")\n# boundaries_wa_2016 <- readOGR(\"//home4/mullerd$/My Documents/Data/2016 Commonwealth Boundaries/WA Final\", \"WA_Electoral_Boundaries_19-01-2016\")\n# boundaries_act_2016 <- readOGR(\"//home4/mullerd$/My Documents/Data/2016 Commonwealth Boundaries/ACT Final\", \"ACT_Electoral_Boundaries_28-01-2016\")\n# \n# boundaries_old_2016 <- boundaries_aust_2013[!boundaries_aust_2013$STATE == \"NSW\",]\n# boundaries_old_2016 <- boundaries_old_2016[!boundaries_old_2016$STATE == \"ACT\",]\n# boundaries_old_2016 <- boundaries_old_2016[!boundaries_old_2016$STATE == \"WA\",]\n# \n# boundaries_nsw_2016$STATE <- factor(\"NSW\")\n# boundaries_wa_2016$STATE <- factor(\"WA\")\n# boundaries_act_2016$STATE <- factor(\"ACT\")\n# \n# # Make sure all of the shapefiles are on the same page\n# proj4string(boundaries_wa_2016) <- proj4string(boundaries_aust_2013)\n# proj4string(boundaries_act_2016) <- proj4string(boundaries_aust_2013)\n# proj4string(boundaries_nsw_2016) <- proj4string(boundaries_aust_2013)\n# \n# # Combine all of the new division maps.\n# boundaries_new_2016 <- rbind(boundaries_wa_2016, boundaries_act_2016, boundaries_nsw_2016, makeUniqueIDs = TRUE)\n\n# Toby's fixed 2016 boundaries\nboundaries_new_2016 <- readOGR(\"../2016 Commonwealth Boundaries/Fixed\", \"COM_ELB_20160509\")\n\n# Reduce the complexity of the district boundary map (default is 46mb)\nlibrary(rgeos)\nboundaries_big_2016 <- boundaries_new_2016\ntmp_data <- data.frame(boundaries_big_2016)\ntmp_shape <- gSimplify(boundaries_big_2016, tol = .01, topologyPreserve = TRUE)\nboundaries_new_2016 <- SpatialPolygonsDataFrame(tmp_shape, tmp_data)\nrm(tmp_shape)\nrm(tmp_data)\n\n# # How to very quickly check a polygon in leaflet (via @tobybellwood)\n# library(leaflet)\n# leaflet() %>% addTiles() %>% addPolygons(data = boundaries_new_2016)\n\n# The variable names are different in the redistribution maps, so we need to rename them\nnames(boundaries_new_2016)[names(boundaries_new_2016) == \"Elect_div\"] <- \"ELECT_DIV\"\nnames(boundaries_new_2016)[names(boundaries_new_2016) == \"Actual\"] <- \"ACTUAL\"\nnames(boundaries_new_2016)[names(boundaries_new_2016) == \"Numccds\"] <- \"NUMCCDS\"\nnames(boundaries_new_2016)[names(boundaries_new_2016) == \"Area_SqKm\"] <- \"AREA_SQKM\"\nnames(boundaries_new_2016)[names(boundaries_new_2016) == \"Projected\"] <- \"PROJECTED\"\nnames(boundaries_new_2016)[names(boundaries_new_2016) == \"Sortname\"] <- \"SORTNAME\"\nnames(boundaries_new_2016)[names(boundaries_new_2016) == \"Total_Popu\"] <- \"POPULATION\"\n\n# # Add the new boundaries to the old boundaries, skipping some variables that aren't in both.\n# boundaries_2016 <- rbind(boundaries_new_2016[, c(-1, -7)], boundaries_old_2016[,-7], makeUniqueIDs = TRUE)\n\n# Some of the division names are not capitalised properly, and this messes up the merge with the notional status\nlevels(boundaries_new_2016$ELECT_DIV) <- gsub(\"Mcpherson\", \"McPherson\", levels(boundaries_new_2016$ELECT_DIV))\nlevels(boundaries_new_2016$ELECT_DIV) <- gsub(\"Mcmillan\", \"McMillan\", levels(boundaries_new_2016$ELECT_DIV))\n\n# Add the notional status\nnotional_status <- read.csv(\"Notional.csv\")\nboundaries_new_2016 <- merge(boundaries_new_2016, notional_status)\n\n# Okay, worked out what I did wrong last time is I need to make two sets of polygons, one for ALP and one for Coalition\n\nboundaries_2016_coalition <- boundaries_new_2016[boundaries_new_2016$Notional == \"Coalition\",]\nboundaries_2016_alp <- boundaries_new_2016[boundaries_new_2016$Notional == \"ALP\",]\nboundaries_2016_nonclassic <- boundaries_new_2016[boundaries_new_2016$Notional == \"Non-Classic\",]\n\n# Invert the ALP margins (turn them into minus margins)\nboundaries_new_2016$RelMargin <- boundaries_new_2016$Margin\nboundaries_new_2016$RelMargin[boundaries_new_2016$Notional == \"ALP\"] <- 0 - boundaries_new_2016$Margin[boundaries_new_2016$Notional == \"ALP\"]\n\n##\n## Polling places\n##\n\n## TODO: \n## - Collapse polling places at the same location together.\n## - Mark abolished polling places and gather their votes into the nearest remaining [hard!]\n\npp_geo <- read.csv(\"http://results.aec.gov.au/17496/Website/Downloads/GeneralPollingPlacesDownload-17496.csv\", header = TRUE, skip = 1)\ntcp_by_pp <- read.csv(\"http://results.aec.gov.au/17496/Website/Downloads/HouseTcpByCandidateByPollingPlaceDownload-17496.csv\", header = TRUE, skip = 1)\n\nlibrary(reshape2)\ntcp_party_pp <- dcast(tcp_by_pp, PollingPlaceID + PollingPlace ~ PartyAb, value.var = \"OrdinaryVotes\")\ntcp_party_pp$COA <- rowSums(cbind(tcp_party_pp$LP, tcp_party_pp$CLP, tcp_party_pp$LNP, tcp_party_pp$NP), na.rm = TRUE)\ntcp_party_pp$TotalVotes <- tcp_party_pp$ALP + tcp_party_pp$COA\ntcp_party_pp$PercentALP <- tcp_party_pp$ALP / tcp_party_pp$TotalVotes\ntcp_party_pp$PercentCOA <- tcp_party_pp$COA / tcp_party_pp$TotalVotes\n\n# Because we're going to merge this with the full polling place results by party, we need to identify these as TPP results by party\nnames(tcp_party_pp) <- gsub(\"^\", \"tpp\", names(tcp_party_pp))\nnames(tcp_party_pp)[1] <- \"PollingPlaceID\"\n\n# Merge TPP and Geocodes\ntcp_party_pp <- merge(tcp_party_pp, pp_geo, by = \"PollingPlaceID\", all.x = TRUE)\n\n# Merge this with the results\ntcp_party_pp <- merge(tcp_party_pp, result_by_pp_2013, by = \"PollingPlaceID\", all.x = TRUE)\n\n# We don't want polling places with no geocodes\ntcp_party_pp <- tcp_party_pp[!is.na(tcp_party_pp$Longitude),]\n\n# Some polling places have a dodgy geocode\ntcp_party_pp <- tcp_party_pp[tcp_party_pp$Longitude > 0,]\n# Dandenong West is on Christmas Island, for some reason\ntcp_party_pp <- tcp_party_pp[tcp_party_pp$PollingPlaceID != 3965,]\n\n# And the mapping is easier if we delete the Norfolk Island polling places (sorry Norfolk Island)\ntcp_party_pp <- tcp_party_pp[tcp_party_pp$PremisesPostCode != 7140,]\n# And Lord Howe Island\ntcp_party_pp <- tcp_party_pp[tcp_party_pp$PremisesPostCode != 2898,]\n# Home Island\ntcp_party_pp <- tcp_party_pp[tcp_party_pp$PremisesPostCode != 6799,]\n# Christmas Island\ntcp_party_pp <- tcp_party_pp[tcp_party_pp$PremisesPostCode != 6798,]\n\n# Also get rid of the polling places which don't have any votes\ntcp_party_pp <- tcp_party_pp[tcp_party_pp$TotalVotes > 0,]\n\n# Tell R what the Latitudes and Longitudes are\ncoordinates(tcp_party_pp) <- c(\"Longitude\", \"Latitude\")\nproj4string(tcp_party_pp) <- proj4string(boundaries_new_2016)\n\ntcp_party_pp <- tcp_party_pp[!is.na(tcp_party_pp$PollingPlaceID),]\n\n# Percantage results for ALP, Coalition, Greens\ntcp_party_pp$PercentALP <- tcp_party_pp$ALP / tcp_party_pp$TotalVotes * 100\ntcp_party_pp$PercentCOA <- (tcp_party_pp$LP + tcp_party_pp$NP + tcp_party_pp$CLP + tcp_party_pp$LNP) / tcp_party_pp$TotalVotes * 100\ntcp_party_pp$PercentGRN <- tcp_party_pp$GRN / tcp_party_pp$TotalVotes * 100\n\n# Determine relative margin (ALP with negative margins)\ntcp_party_pp$tppRelative <- tcp_party_pp$tppPercentCOA - 0.5\n\n# Break down polling places into TPP groups\ntcp_pp_alp <- tcp_party_pp[!is.na(tcp_party_pp$tppPercentALP),]\ntcp_pp_alp <- tcp_pp_alp[tcp_pp_alp$tppPercentALP >= 0.5,]\n\ntcp_pp_coa <- tcp_party_pp[!is.na(tcp_party_pp$tppPercentCOA),]\ntcp_pp_coa <- tcp_pp_coa[tcp_pp_coa$tppPercentCOA >= 0.5,]\n\n##\n## Draw the map\n##\n\nlibrary(leaflet)\n\npal_grn_percent <- colorNumeric(\n  palette = \"Greens\",\n  domain = tcp_party_pp$PercentGRN\n)\n\npal_alp_percent <- colorNumeric(\n  palette = \"Reds\",\n  domain = tcp_party_pp$PercentALP\n)\n\npal_coa_percent <- colorNumeric(\n  palette = \"Blues\",\n  domain = tcp_party_pp$PercentCOA\n)\n\npal_coalition <- colorNumeric(\n  palette = \"Blues\", \n  domain = boundaries_new_2016$Margin\n)\n\npal_alp <- colorNumeric(\n  palette = \"Reds\", \n  domain = boundaries_new_2016$Margin\n)\n\npal_nonclassic <- colorNumeric(\n  palette = \"Greens\",\n  domain = boundaries_new_2016$Margin\n)\n\npal_pp_alp <- colorNumeric(\n  palette = \"Reds\",\n  domain = tcp_pp_alp$tppPercentALP\n)\n\npal_pp_coa <- colorNumeric(\n  palette = \"Blues\",\n  domain = tcp_pp_coa$tppPercentCOA\n)\n\ncontent_alp <- paste(\n  \"<b>\", boundaries_2016_alp$ELECT_DIV, \"</b><br />\",\n  \"Notional Party:\", boundaries_2016_alp$Notional, \"<br />\",\n  \"Notional Margin:\", round(boundaries_2016_alp$Margin, digits = 1), \"<br />\",\n  \"Held By:\", boundaries_2016_alp$HeldBy, \"<br />\"\n)\n\ncontent_coalition <- paste(\n  \"<b>\", boundaries_2016_coalition$ELECT_DIV, \"</b><br />\",\n  \"Notional Party:\", boundaries_2016_coalition$Notional, \"<br />\",\n  \"Notional Margin:\", round(boundaries_2016_coalition$Margin, digits = 1), \"<br />\",\n  \"Held By:\", boundaries_2016_coalition$HeldBy, \"<br />\"\n)\n\ncontent_nonclassic <- paste(\n  \"<b>\", boundaries_2016_nonclassic$ELECT_DIV, \"</b><br />\",\n  \"Notional Party:\", boundaries_2016_nonclassic$Notional, \"<br />\",\n  \"Notional Margin:\", round(boundaries_2016_nonclassic$Margin, digits = 1), \"<br />\",\n  \"Held By:\", boundaries_2016_nonclassic$HeldBy, \"<br />\"\n)\n\ncontent_pp <- paste(\n  \"<b>\", tcp_party_pp$PollingPlace, \"(\", tcp_party_pp$PremisesSuburb, \", \", tcp_party_pp$PremisesStateAb, \")</b><br />\",\n  \"ALP primary vote: \", tcp_party_pp$ALP, \" (\", round(tcp_party_pp$PercentALP, digits = 1), \"%)<br />\",\n  \"ALP Two Party Preferred: \", round(tcp_party_pp$tppPercentALP * 100, digits = 1), \"%)<br />\",\n  \"Coalition primary vote: \", tcp_party_pp$COA, \" (\", round(tcp_party_pp$PercentCOA, digits = 1), \"%)<br />\",\n  \"Coalition Two Party Preferred: \", round(tcp_party_pp$tppPercentCOA * 100, digits = 1), \"%)<br />\",\n  \"Greens primary vote: \", tcp_party_pp$GRN, \" (\", round(tcp_party_pp$PercentGRN, digits = 1), \"%)<br />\",\n  \"Total votes: \", tcp_party_pp$TotalVotes, \"<br />\",\n  sep = \"\"\n)\n\ncontent_tcp_coa <- paste(\n  \"<b>\", tcp_pp_coa$PollingPlace, \" (\", tcp_pp_coa$PremisesSuburb, \", \", tcp_pp_coa$PremisesStateAb, \")</b><br />\",\n  \"ALP primary vote: \", tcp_pp_coa$ALP, \" (\", round(tcp_pp_coa$PercentALP, digits = 1), \"%)<br />\",\n  \"ALP Two Party Preferred: \", round(tcp_pp_coa$tppPercentALP * 100, digits = 1), \"%<br />\",\n  \"Coalition primary vote: \", tcp_pp_coa$COA, \" (\", round(tcp_pp_coa$PercentCOA, digits = 1), \"%)<br />\",\n  \"Coalition Two Party Preferred: \", round(tcp_pp_coa$tppPercentCOA * 100, digits = 1), \"%<br />\",\n  \"Greens primary vote: \", tcp_pp_coa$GRN, \" (\", round(tcp_pp_coa$PercentGRN, digits = 1), \"%)<br />\",\n  \"Total votes: \", tcp_pp_coa$TotalVotes, \"<br />\",\n  sep = \"\"\n)\n\ncontent_tcp_alp <- paste(\n  \"<b>\", tcp_pp_alp$PollingPlace, \" (\", tcp_pp_alp$PremisesSuburb, \", \", tcp_pp_alp$PremisesStateAb, \")</b><br />\",\n  \"ALP primary vote: \", tcp_pp_alp$ALP, \" (\", round(tcp_pp_alp$PercentALP, digits = 1), \"%)<br />\",\n  \"ALP Two Party Preferred: \", round(tcp_pp_alp$tppPercentALP * 100, digits = 1), \"%<br />\",\n  \"Coalition primary vote: \", tcp_pp_alp$COA, \" (\", round(tcp_pp_alp$PercentCOA, digits = 1), \"%)<br />\",\n  \"Coalition Two Party Preferred: \", round(tcp_pp_alp$tppPercentCOA * 100, digits = 1), \"%<br />\",\n  \"Greens primary vote: \", tcp_pp_alp$GRN, \" (\", round(tcp_pp_alp$PercentGRN, digits = 1), \"%)<br />\",\n  \"Total votes: \", tcp_pp_alp$TotalVotes, \"<br />\",\n  sep = \"\"\n)\n\n# For some reason it doesn't render properly when I have the popups added.\n# The reason seems to be that it's too complex when combined with the boundary maps.\n\nm <- leaflet()\n\nm %>%  \n  addProviderTiles(\"CartoDB.Positron\") %>% \n  addPolygons(data = boundaries_2016_alp, color = ~pal_alp(boundaries_2016_alp$Margin), popup = content_alp, stroke = FALSE, fillOpacity = 0.7, group = \"Notional Margin\") %>%\n  addPolygons(data = boundaries_2016_coalition, color = ~pal_coalition(boundaries_2016_coalition$Margin), popup = content_coalition, stroke = FALSE, fillOpacity = 0.7, group = \"Notional Margin\") %>%\n  addPolygons(data = boundaries_2016_nonclassic, color = ~pal_nonclassic(boundaries_2016_nonclassic$Margin), popup = content_nonclassic, stroke = FALSE, fillOpacity = 0.7, group = \"Notional Margin\") %>%\n  addPolylines(data = boundaries_new_2016, weight = 1, stroke = TRUE, opacity = 1, color = \"Black\", group = \"2016 Boundary\") %>%\n  addCircleMarkers(data = tcp_pp_alp, popup = content_tcp_alp, color = ~pal_pp_alp(tcp_pp_alp$tppPercentALP), stroke = FALSE, radius = 4, fillOpacity = 0.6, group = \"Two Party Preferred\") %>%\n  addCircleMarkers(data = tcp_pp_coa, popup = content_tcp_coa, color = ~pal_pp_coa(tcp_pp_coa$tppPercentCOA), stroke = FALSE, radius = 4, fillOpacity = 0.6, group = \"Two Party Preferred\") %>%\n  addCircleMarkers(data = tcp_party_pp, popup = content_pp, color = ~pal_coa_percent(tcp_party_pp$PercentCOA), stroke = FALSE, radius = 4, fillOpacity = 0.6, group = \"Coalition Primary\") %>%\n  addCircleMarkers(data = tcp_party_pp, popup = content_pp, color = ~pal_alp_percent(tcp_party_pp$PercentALP), stroke = FALSE, radius = 4, fillOpacity = 0.6, group = \"ALP Primary\") %>%\n  addCircleMarkers(data = tcp_party_pp, popup = content_pp, color = ~pal_grn_percent(tcp_party_pp$PercentGRN), stroke = FALSE, radius = 4, fillOpacity = 0.6, group = \"Greens Primary\") %>%\n  hideGroup(\"2016 Boundary\") %>%\n  addLayersControl(\n    baseGroups = c(\"Two Party Preferred\", \"Coalition Primary\", \"ALP Primary\", \"Greens Primary\"),\n    overlayGroups = c(\"Notional Margin\", \"2016 Boundary\"),\n    options = layersControlOptions(collapsed = FALSE)\n  )\n\n\n# Delete the stuff we don't need any more\n\n# rm(boundaries_new_2016)\n# rm(m)\n",
    "created" : 1463649132670.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3851456215",
    "id" : "DAB7076D",
    "lastKnownWriteTime" : 1464258277,
    "last_content_update" : 1464258277192,
    "path" : "~/Documents/Dev/R/Electoral Map 2016/Electoral Map 2016.R",
    "project_path" : "Electoral Map 2016.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}